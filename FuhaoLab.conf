#!/bin/bash

### Please configure ###

if [ -z "$PROGPATH" ]; then
	if [ ! -z "$PROGRAMHOME" ]; then
		export PROGRAMHOME=PROGRAMHOME;
	else
		export PROGPATH=${HOME}/Programs;
	fi
fi
if [ -z "$BIODATABASES" ]; then
	export BIODATABASES=${HOME}/Databases;
fi
if [ -z "$InstallPlatform" ]; then
	InstallPlatform='PC'
fi
if [ -z "$EnvironFilePath" ]; then
	export EnvironFilePath=${HOME}/.bashrc
fi


### Configure End ###


if [ ! -d ${PROGPATH}/bin ]; then
	mkdir -p ${PROGPATH}/bin
	export PATH=${PROGPATH}/bin:$PATH
fi


function CmdExists {
  if command -v $1 >/dev/null 2>&1; then
    return 0
  else
    return 1
  fi
}


###Please configure InstallPlatform
# For Linux cluster, choose HPC
#InstallPlatform='HPC'
#For personal PC or workstation
#InstallPlatform='PC'
if [[ $InstallPlatform == "PC" ]]; then
	export EnvironFilePath=${HOME}/.bashrc
elif [[ $InstallPlatform == "HPC" ]]; then
	if [ ! -d ${PROGPATH}/bin ]; then
		mkdir -p ${PROGPATH}/bin
	fi
	export EnvironFilePath=${PROGPATH}/bin/myprogram
else
	export EnvironFilePath=${HOME}/.bashrc
fi



### Print important info
function PrintInfo {
	local PTmessage=$1
	
	echo -e "\033[42;31m${PTmessage}\033[0m"
	return 0
}
### Print important info
function PrintError {
	local PTmessage=$1
	
	echo -e "\033[41;37m${PTmessage}\033[0m" >&2
	return 0
}



###echo color
#Black        0;30     Dark Gray     1;30
#Red          0;31     Light Red     1;31
#Green        0;32     Light Green   1;32
#Brown/Orange 0;33     Yellow        1;33
#Blue         0;34     Light Blue    1;34
#Purple       0;35     Light Purple  1;35
#Cyan         0;36     Light Cyan    1;36
#Light Gray   0;37     White         1;37
#RED=\'\033[0;31m\'
#NC=\'\033[0m\' # No Color
#printf "I ${RED}love${NC} Stack Overflow\n"
function RunCmds {
	RCcmd=$1;
	
	PrintInfo "$RCcmd"
	$RCcmd
	if [ $? -ne 0 ]; then
		PrintError "Error: cmd failed"
		echo "CMD: $RCcmd" >&2
		exit 100
	else
		return 0
	fi
}


if [ ! -z $(uname -m) ]; then
	export MACHTYPE=$(uname -m)
elif [ ! -z "$MACHTYPE" ]; then
	MTemp=${MACHTYPE%%-*}
	export MACHTYPE=$MTemp
else
	PrintError "Warnings: unknown MACHTYPE, set to default x86_64" >&2
	export MACHTYPE="x86_64"
fi


### change to install path
function CheckPath {
	local CPname=$1
	local CPvers=$2
	
	local CPinstall_path=$PROGPATH/$CPname/$CPvers
	PrintInfo "Installing Path: $CPinstall_path"

	if [ ! -d $CPinstall_path ]; then
		mkdir -p $CPinstall_path
	fi
	cd $CPinstall_path
	return 0;
}

### change to install LIB path
function CheckLibPath {
	local CPname=$1
	local CPvers=$2
	
	local CPinstall_path=${PROGPATH}/libraries/$CPname/$CPvers
	echo "Install Path: $CPinstall_path"

	if [ ! -d $CPinstall_path ]; then
		mkdir -p $CPinstall_path
	fi
	
	cd $CPinstall_path
	
	return 0;
}


### Download using wget
function DownloadWget {
	local DWlink=$1
	local DWname=$2
	
	
	if [ ! -s $DWname ]; then
		PrintInfo "Downloading $DWname"
		PrintInfo "       from $DWlink"
		wget --tries 5 -c $DWlink -O $DWname
		if [ $?  -ne 0 ]; then
			PrintError "Error: failed to download package $DWname"
			PrintError "CMD used: wget -c $DWlink -O $DWname"
			PrintInfo  "Please retry or manually download the package from $DWlink, "
			PrintInfo  "    and rename it to $DWname"
			if [ -e $DWname ]; then
				rm -rf $DWname >/dev/null 2>&1
			fi
			exit 100
		fi
	else
		PrintInfo "Info: existing $DWname"
	fi
	
	return 0
}



### Environment
function AddEnvironVariable {
	local EVpath=$1
	local EVcomt=$2
	
	echo -e "\n\n\n"
	echo "### $EVcomt" >> $EnvironFilePath
	if [ -d $EVpath/bin ]; then
		PrintInfo "#Info: if you want it in effect immediately"
		PrintInfo "export PATH=$EVpath/bin:\$PATH"
		echo "#Info: adding to PATH to $EnvironFilePath"
		echo "export PATH=$EVpath/bin:\$PATH" >> $EnvironFilePath
	else
		local -a ExcArr=()
		ExcArr=($(find $EVpath/ -maxdepth 1 -perm /+x -type f))
		if [ ${#ExcArr[@]} -gt 0 ]; then
			PrintInfo "#Info: if you want it in effect immediately"
			PrintInfo "export PATH=$EVpath:\$PATH"
			echo "#Info: adding to PATH to $EnvironFilePath"
			echo "export PATH=$EVpath:\$PATH" >> $EnvironFilePath
		else
			PrintError "Warnings: no executables in $EVpath"
		fi
	fi
	
	if [ -d $EVpath/lib ]; then
		PrintInfo "#Info: if you want it in effect immediately"
		PrintInfo "export LIBRARY_PATH=$EVpath/lib:\$LIBRARY_PATH"
		PrintInfo "export LD_LIBRARY_PATH=$EVpath/lib:\$LD_LIBRARY_PATH"
		echo "#Info: adding Libs to $EnvironFilePath"
		echo "export LIBRARY_PATH=$EVpath/lib:\$LIBRARY_PATH" >> $EnvironFilePath
		echo "export LD_LIBRARY_PATH=$EVpath/lib:\$LD_LIBRARY_PATH" >> $EnvironFilePath
		
		if [ -d $EVpath/lib/pkgconfig ]; then
			PrintInfo "#Info: if you want it in effect immediately"
			PrintInfo "export PKG_CONFIG_PATH=$EVpath/lib/pkgconfig:\$PKG_CONFIG_PATH"
			echo "#Info: adding Libs to $EnvironFilePath"
			echo "export PKG_CONFIG_PATH=$EVpath/lib/pkgconfig:\$PKG_CONFIG_PATH" >> $EnvironFilePath
		fi
	fi
	if [ -d $EVpath/include ]; then
		PrintInfo "#Info: if you want it in effect immediately"
		PrintInfo "export C_INCLUDE_PATH=$EVpath/include:\$C_INCLUDE_PATH"
		PrintInfo "export CPLUS_INCLUDE_PATH=$EVpath/include:\$CPLUS_INCLUDE_PATH"
		echo "#Info: adding headers to $EnvironFilePath"
		echo "export C_INCLUDE_PATH=$EVpath/include:\$C_INCLUDE_PATH" >> $EnvironFilePath
		echo "export CPLUS_INCLUDE_PATH=$EVpath/include:\$CPLUS_INCLUDE_PATH" >> $EnvironFilePath
	fi
	if [ -d $EVpath/share/man ]; then
		PrintInfo "#Info: if you want it in effect immediately"
		PrintInfo "export MANPATH=$EVpath/share/man:\$MANPATH"
		echo "#Info: adding headers to $EnvironFilePath"
		echo "export MANPATH=$EVpath/share/man:\$MANPATH" >> $EnvironFilePath
	fi
### to be continued
}



function AddBashrc {
	local ABstr=$1
	
	PrintInfo "$ABstr"
	echo "$ABstr" >> $EnvironFilePath
	
	return 0
}



function CheckPythonModules {
	local CMname=$1
	
	if [ ! -x ${HOME}/.local/bin/$CMname ]; then
		return 1;
	fi
	
	return 0
}



function DeletePath {
	local DParr=($@)
	
#	echo "Deleting path"
	for DPinddir in ${DParr[@]}; do
#		echo "Depeting path: $DPinddir"
		if [ -d "$DPinddir" ]; then
			rm -rf "$DPinddir"
		fi
	done
	
	return 0
}
function DeleteCreatePath {
	local DParr=($@)
	
#	echo "Deleting path"
	for DPinddir in ${DParr[@]}; do
#		echo "Depeting path: $DPinddir"
		if [ -d "$DPinddir" ]; then
			rm -rf "$DPinddir"
		fi
		mkdir -p $DPinddir
	done
	
	return 0
}



function Md5Check {
	local MCfile=$1
	
	md5sum -c $MCfile
	if [ $? -eq 0 ]; then
		return 0
	elif [ $? -eq 0 ]; then
		PrintError "Error: md5 Not match"
		exit 100
	else
		PrintError "Error: failed to run md5sum"
		exit 200
	fi
}
function Md5Check {
	local MCfile=$1
	
	PrintInfo "Info: checking SHA1: $MCfile"
	sha1sum -c $MCfile
	if [ $? -eq 0 ]; then
		return 0
	elif [ $? -eq 0 ]; then
		PrintError "Error: SHA1 Not match"
		exit 100
	else
		PrintError "Error: failed to run sha1"
		exit 200
	fi
}



function TopFolderName {
	local UFfile=$1
	local -a UFarr=()
	
	if [[ "$UFfile" =~ *.[tT][aA][rR].[gG][zZ]$ ]]; then
		tar -pxzvf $UFfile >$UFfile.tar.log 2>&1
		if [ $? -ne 0 ]; then
			UFarr=($(cat $UFfile.tar.log | cut -f 1 -d'/' | sort -u))
			for UFind in ${UFarr[@]}; do
				rm -rf $UFind >/dev/null 2>&1
			done
			PrintError "Error: uncompress error using tar: $UFfile"
			rm -rf $UFfile.tar.log >/dev/null 2>&1
			exit 100
		else
			rm -rf $UFfile.tar.log >/dev/null 2>&1
			return 0
		fi
	elif [[ "$UFfile" =~ *.[zZ][iI][pP]$ ]]; then
		unzip $UFfile > $UFfile.unzip.log
		if [ $? -ne 0 ]; then
			UFarr=($(cat $UFfile.unzip.log | grep ^'   creating\|  inflating' | sed 's/^[ ]*creating:\s\+//;s/^[ ]*inflating:\s\+//;' | cut -f 1 -d'/' | sort -u))
			for UFind in ${UFarr[@]}; do
				rm -rf $UFind >/dev/null 2>&1
			done
			PrintError "Error: uncompress error using unzip: $UFfile"
			rm -rf $UFfile.unzip.log >/dev/null 2>&1
			exit 100
		else
			rm -rf $UFfile.unzip.log >/dev/null 2>&1
			return 0
		fi
	fi
}



function DecompressFile {
	local UFfile=$1
	local -a UFarr=()
	
	if [[ "$UFfile" =~ .*\.[tT][aA][rR].[gG][zZ]$ ]]; then
		echo "Info: tar.gz file: $UFfile"
		tar -pxzvf $UFfile >$UFfile.tar.log 2>&1
		if [ $? -ne 0 ]; then
			UFarr=($(cat $UFfile.tar.log | cut -f 1 -d'/' | sort -u))
			for UFind in ${UFarr[@]}; do
				rm -rf $UFind >/dev/null 2>&1
			done
			PrintError "Error: uncompress error using tar: $UFfile"
			rm -rf $UFfile.tar.log >/dev/null 2>&1
			exit 100
		else
			rm -rf $UFfile.tar.log >/dev/null 2>&1
			return 0
		fi
	elif [[ "$UFfile" =~ .*\.[zZ][iI][pP]$ ]]; then
		echo "Info: zip file: $UFfile"
		unzip $UFfile > $UFfile.unzip.log
		if [ $? -ne 0 ]; then
			UFarr=($(cat $UFfile.unzip.log | grep ^'   creating\|  inflating' | sed 's/^[ ]*creating:\s\+//;s/^[ ]*inflating:\s\+//;' | cut -f 1 -d'/' | sort -u))
			for UFind in ${UFarr[@]}; do
				rm -rf $UFind >/dev/null 2>&1
			done
			PrintError "Error: uncompress error using unzip: $UFfile"
			rm -rf $UFfile.unzip.log >/dev/null 2>&1
			exit 100
		else
			rm -rf $UFfile.unzip.log >/dev/null 2>&1
			return 0
		fi
	else
		PrintError "Error: uknown format to decompress: $UFfile"
		exit 100
	fi
}

